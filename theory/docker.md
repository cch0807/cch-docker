
# 컨테이너 나열하기

- CONTAINER ID: 컨테이너의 고유한 아이디 해쉬값. 실제로는 더욱 길지만 일부만 표출
- IMAGE: 컨테이너 생성시 사용한 도커 이미지
- COMMAND: 컨테이너 시작시 실행될 명령어. 대부분 이미지에 내장되어있음
- CREATED: 컨테이너가 실행된 시간
- STATUS: 컨테이너의 상태
- PORTS: 컨테이너가 개방한 포트와 호스트에 연결한 포트.
- NAMES: 컨테이너 고유한 이름. docker rename 명령어로 변경 가능.

docker ps --format 'table{{.Names}}\table{{.Image}}'

# 도커 컨테이너의 생명주기
생성(create) -> 시작(start) -> 실행(running) -> 중지(stopped) -> 삭제(deleted)

docker create <이미지 이름> 
docker start -a <컨테이너 이미지/이름>

docker stop <컨테이너 아이디/이름>
docker kill <컨테이너 아이디/이름>

- stop과 kill의 차이?
    - Stop은 Gracefully하게 중지 시킨다.
    - kill은 stop과 달리 어떠한 것도 기다리지않고 바로 컨테이너를 중지시킨다.

docker rm <아이디/이름>
docker rm 'docker ps -a -q'

- docker system prune
    - 도커를 쓰지 않을때 모두 정리하고 싶을때 사용하면 좋다.
    - 하지만 이것도 실행중인 컨테이너에는 영향을 주지 않는다.


# 실행중인 컨테이너에 명령어 전달

- docker exec <컨테이너 아이디/이름>

# 레디스를 이용한 컨테이너 이해

1. 레디스 서버를 작동.
    - docker run redis

2. 레디스 클라이언트 작동
    - docker exec -it <컨테이너 아이디/이름> redis-cli
    - it란 interactive terminal 의 약자이다.

# 실행중인 컨테이너에서 터미널 사용하기

- docker exec -it <컨테이너 아이디/이름> sh 또는 bash

# 도커 이미지 생성하기

- 도커 이미지는 컨테이너를 만들기 위해 필요한 설정이나 종속성들을 갖고있는 소프트웨어 패키지.
- 도커 이미지는 Dockerhub에 이미 만들어 놓은것을 사용할 수 있다.
- 직접 도커 이미지를 만들어서 사용할 수 있고 만든것을 Dockerhub에 업로드 할 수 있다.

- Dockerfile 작성 -> 도커 클라이언트 -> 도커 서버 -> 이미지 생성

1. Dockerfile 작성
    - Dockerfile 이란 Docker Image를 만들기 위한 설정 파일
    - 컨테이너가 어떻게 행동해야 하는지에 대한 설정들을 정의해줌.

2. 도커 클라이언트
    - 도커 파일에 입력된 것들이 도커 클라이언트에 전달되어야 한다.

3. 도커 서버
    - 도커 클라이언트에 전달된 모든 중요한 작업들을 하는 곳

# 도커 파일 만드는 순서 (도커 이미지가 필요한 것이 무엇인지 생각하기)
1. 베이스 이미지를 명시한다. (파일 스냅샷에 해당)
2. 추가적으로 필요한 파일을 다운 받기 위한 몇가지 명령어를 명시한다.(파일 스냅샷에 해당)
3. 컨테이너 시작 시 실행 될 명령어를 명시한다. (시작시 실행 될 명령어에 해당)

# 베이스 이미지?
- 도커 이미지는 여러개의 레이어로 되어 있다. 그중에서 베이스 이미지는 기반이 되는 부분이다.
- 레이어는 중간 단계의 이미지라고 생각하면 된다.
- 만약 이미지에 무언가를 추가한다면 레이어가 추가된다(레이어 캐싱)!

# 도커파일로 이미지 생성하기
- 도커 파일에 입력된 것들이 도커 클라이언트에 전달되어서 도커 서버가 인식하게 하여야 한다.
- docker build ./ 또는 docker build .
- Build 명령어는
    - 해당 디렉토리 내에서 dockerfile이라는 파일을 찾아서 도커 클라이언트에 전달.

# 로컬 머신 node_modules
- node_modules에는 리엑트 앱을 실행할 때 필요한 모듈들이 들어있지만, 이미지를 빌드 할 때 이미 npm install로 모든 모듈들을 도커 이미지에 다운 받기 때문에 굳이 로컬 머신에 node_modules을 필요로 하지 않는다.
그러기에 node_modules를 지워주는게 좋다!

# 운영환경을 위한 nginx
- 개발에서 사용하는 서버는 소스를 변경하면 자동으로 전체 앱을 다시 빌드해서 변경 소스를 반영해주는 것 같이 개발 환경에 특화된 기능들이 있기에 그러한 기능이 없는 Nginx 서버보다 더욱 적합하다.
- 운영환경에서는 소스를 변경할 때 다시 반영해줄 필요가 없으며, 개발에 필요한 기능들이 필요하지 않기에 더 깔끔하고 빠른 Nginx를 웹 서버로 사용한다.

# Travis CI ?
- Travis CI는 Github에서 진행되는 오픈소스 프로젝트를 위한 지속적인 통합(Continuous Integration) 서비스이다. 2011년에 설립되어 2012년에 급성장하였으며 Ruby언어만 지원하였지만 현재 대부분의 개발 언어를 지원하고 있다.
- Travis CI를 이용하면 Github repository에 있는 프로젝트를 특정 이벤트에 따라 자동으로 테스트, 빌드하거나 배포할 수 있다. Private repository는 유료로 일정 금액을 지불하고 사용할 수 있다.

# Travis CI의 흐름
- 로컬 Git -> Github -> Travis CI -> AWS

1. 로컬 Git에 있는 소스를 Github 저장소에 Push한다.
2. Github master 저장소에 소스가 Push가 되면 Travis CI에게 소스가 Push 되었다고 얘기해준다.
3. Travis CI는 업데이트 된 소스를 Github에서 가지고 온다.
4. github에서 가져온 소스의 테스트 코드를 실행한다.
5. 테스트 코드 실행 후 테스트가 성공하면 AWS 같은 호스팅 사이트에 배포한다.